From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <novau233@163.com>
Date: Sun, 26 May 2024 11:26:08 +0000
Subject: [PATCH] Base Dirty Patches


diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java b/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
index 190c5f0b02a3d99054704ae1afbffb3498ddffe1..8106114c49e4589a70bf00430a83a132a049e2db 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
@@ -20,15 +20,15 @@ public final class ReferenceList<E> implements Iterable<E> {
     protected Object[] references = EMPTY_LIST;
     protected int count;
 
-    public int size() {
+    public synchronized int size() {
         return this.count;
     }
 
-    public boolean contains(final E obj) {
+    public synchronized boolean contains(final E obj) {
         return this.referenceToIndex.containsKey(obj);
     }
 
-    public boolean remove(final E obj) {
+    public synchronized boolean remove(final E obj) {
         final int index = this.referenceToIndex.removeInt(obj);
         if (index == Integer.MIN_VALUE) {
             return false;
@@ -47,7 +47,7 @@ public final class ReferenceList<E> implements Iterable<E> {
         return true;
     }
 
-    public boolean add(final E obj) {
+    public synchronized boolean add(final E obj) {
         final int count = this.count;
         final int currIndex = this.referenceToIndex.putIfAbsent(obj, count);
 
@@ -68,22 +68,22 @@ public final class ReferenceList<E> implements Iterable<E> {
         return true;
     }
 
-    public E getChecked(final int index) {
+    public synchronized E getChecked(final int index) {
         if (index < 0 || index >= this.count) {
             throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
         }
         return (E)this.references[index];
     }
 
-    public E getUnchecked(final int index) {
+    public synchronized E getUnchecked(final int index) {
         return (E)this.references[index];
     }
 
-    public Object[] getRawData() {
+    public synchronized Object[] getRawData() {
         return this.references;
     }
 
-    public void clear() {
+    public synchronized void clear() {
         this.referenceToIndex.clear();
         Arrays.fill(this.references, 0, this.count, null);
         this.count = 0;
@@ -96,12 +96,12 @@ public final class ReferenceList<E> implements Iterable<E> {
             private int current;
 
             @Override
-            public boolean hasNext() {
+            public synchronized boolean hasNext() {
                 return this.current < ReferenceList.this.count;
             }
 
             @Override
-            public E next() {
+            public synchronized E next() {
                 if (this.current >= ReferenceList.this.count) {
                     throw new NoSuchElementException();
                 }
@@ -109,7 +109,7 @@ public final class ReferenceList<E> implements Iterable<E> {
             }
 
             @Override
-            public void remove() {
+            public synchronized void remove() {
                 final E lastRet = this.lastRet;
 
                 if (lastRet == null) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
index 239475187fdf0d05823b31e2068651559d3497e5..260c29732fec8faecb20c274073952c5e8f3da76 100644
--- a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
@@ -221,7 +221,7 @@ public class RegionizedPlayerChunkLoader {
     public void updatePlayer(final ServerPlayer player) {
         final PlayerChunkLoaderData loader = player.chunkLoader;
         if (loader != null) {
-            player.serverLevel().chunkSource.chunkMap.getNearbyPlayers().tickPlayer(player); // Folia - region threading
+            player.serverLevel().chunkSource.chunkMap.level.regionizedWorldDataAccessor.getAny(player).getNearbyPlayers().tickPlayer(player); // Folia - region threading
             loader.update();
         }
     }
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 5bef4f50082e56b89239cfd62dd7429926b71c09..9e81cfcdfd6c4ed13130cbef28cd9a07cd8bb3ca 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -443,7 +443,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
         entity.setLevelCallback(new EntityCallback(entity));
 
-        this.world.getCurrentWorldData().addEntity(entity); // Folia - region threading
+        this.world.regionizedWorldDataAccessor.getAny(entity).addEntity(entity); // Folia - region threading
 
         this.entityStatusChange(entity, slices, Visibility.HIDDEN, getEntityStatus(entity), false, !fromDisk, false);
 
@@ -888,7 +888,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         @Override
         public void onMove() {
             final Entity entity = this.entity;
-            final io.papermc.paper.threadedregions.RegionizedWorldData regionData = entity.level().getCurrentWorldData(); // Folia - region threading
+            final io.papermc.paper.threadedregions.RegionizedWorldData regionData = entity.level().regionizedWorldDataAccessor.getAny(entity); // Folia - region threading
             final Visibility oldVisibility = getEntityStatus(entity);
             final ChunkEntitySlices newSlices = EntityLookup.this.moveEntity(this.entity);
             if (newSlices == null) {
@@ -918,7 +918,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
             this.entity.setLevelCallback(NoOpCallback.INSTANCE);
 
             // only AFTER full removal callbacks, so that thread checking will work. // Folia - region threading
-            EntityLookup.this.world.getCurrentWorldData().removeEntity(entity); // Folia - region threading
+            EntityLookup.this.world.regionizedWorldDataAccessor.getAny(entity).removeEntity(entity); // Folia - region threading
         }
     }
 
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
index 6369b13e1fcdbdb25dd9d6e4d3bffdedbee4f739..740d7994a76e73332fb8b4accf388a550e0cf6ce 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
@@ -26,7 +26,7 @@ class PaperPluginProviderFactory implements PluginTypeFactory<PaperPluginParent,
     public PaperPluginParent build(JarFile file, PaperPluginMeta configuration, Path source) {
         // Folia start - block plugins not marked as supported
         if (!configuration.isFoliaSupported()) {
-            throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
+         //   throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
         }
         // Folia end - block plugins not marked as supported
         Logger jul = PaperPluginLogger.getLogger(configuration);
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
index 1b2964d5a3d839950e6831b7542e9587187bd375..e1b9659e9884bd1912c34b17337647859406f653 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
@@ -28,7 +28,7 @@ class SpigotPluginProviderFactory implements PluginTypeFactory<SpigotPluginProvi
     public SpigotPluginProvider build(JarFile file, PluginDescriptionFile configuration, Path source) throws InvalidDescriptionException {
         // Folia start - block plugins not marked as supported
         if (!configuration.isFoliaSupported()) {
-            throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
+           // throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
         }
         // Folia end - block plugins not marked as supported
         // Copied from SimplePluginManager#loadPlugins
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
index 1ae61bc6603dd3ac290e3ead20416f9c5b63ff02..9099dea8b7053c745a108123bafdfa5d10133db1 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -19,6 +19,7 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.world.level.GameRules;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.slf4j.Logger;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -102,7 +103,7 @@ public final class RegionizedServer {
 
     public static void ensureGlobalTickThread(final String reason) {
         if (!isGlobalTickThread()) {
-            throw new IllegalStateException(reason);
+           //throw new IllegalStateException(reason);
         }
     }
 
@@ -293,6 +294,9 @@ public final class RegionizedServer {
         // scheduler
         ((FoliaGlobalRegionScheduler)Bukkit.getGlobalRegionScheduler()).tick();
 
+        //Bukkit scheduler
+        ((CraftScheduler) Bukkit.getScheduler()).mainThreadHeartbeat((int)this.tickCount);
+
         // commands
         ((DedicatedServer)MinecraftServer.getServer()).handleConsoleInputs();
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 245efed41de40dc506301af942a7f3c3a2b60d65..6bdc2e6f527ecc6c4e4b6b4461e9f08034db144e 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -3,6 +3,9 @@ package io.papermc.paper.threadedregions;
 import com.destroystokyo.paper.util.maplist.ReferenceList;
 import com.destroystokyo.paper.util.misc.PlayerAreaMap;
 import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
 import io.papermc.paper.util.CoordinateUtils;
@@ -12,7 +15,9 @@ import io.papermc.paper.util.player.NearbyPlayers;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceMap;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ObjectLists;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
@@ -92,10 +97,10 @@ public final class RegionizedWorldData {
             for (final Entity entity : from.toProcessTrackingUnloading) {
                 into.toProcessTrackingUnloading.add(entity);
             }
-            for (final Iterator<Entity> iterator = from.entityTickList.unsafeIterator(); iterator.hasNext();) {
+            for (final Iterator<Entity> iterator = from.entityTickList.iterator(); iterator.hasNext();) {
                 into.entityTickList.add(iterator.next());
             }
-            for (final Iterator<Mob> iterator = from.navigatingMobs.unsafeIterator(); iterator.hasNext();) {
+            for (final Iterator<Mob> iterator = from.navigatingMobs.iterator(); iterator.hasNext();) {
                 into.navigatingMobs.add(iterator.next());
             }
             // block ticking
@@ -313,7 +318,7 @@ public final class RegionizedWorldData {
     private RegionizedServer.WorldLevelData tickData;
 
     // connections
-    public final List<Connection> connections = new ArrayList<>();
+    public final List<Connection> connections = ObjectLists.synchronize(new ObjectArrayList<>());
 
     // misc. fields
     private boolean isHandlingTick;
@@ -327,12 +332,12 @@ public final class RegionizedWorldData {
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    private final List<ServerPlayer> localPlayers = Lists.newCopyOnWriteArrayList();
     private final NearbyPlayers nearbyPlayers;
     private final ReferenceList<Entity> allEntities = new ReferenceList<>();
     private final ReferenceList<Entity> loadedEntities = new ReferenceList<>();
     private final ReferenceList<Entity> toProcessTrackingUnloading = new ReferenceList<>();
-    private final IteratorSafeOrderedReferenceSet<Entity> entityTickList = new IteratorSafeOrderedReferenceSet<>();
+    private final IteratorSafeOrderedReferenceSet<Entity> entityTickList = new IteratorSafeOrderedReferenceSet<>();//Sets.newConcurrentHashSet();//ObjectSets.synchronize(new ObjectLinkedOpenHashSet<>());
     private final IteratorSafeOrderedReferenceSet<Mob> navigatingMobs = new IteratorSafeOrderedReferenceSet<>();
 
     // block ticking
@@ -341,8 +346,8 @@ public final class RegionizedWorldData {
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
-    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = Collections.synchronizedList(new ArrayList<>());
+    private final List<TickingBlockEntity> blockEntityTickers = Collections.synchronizedList(new ArrayList<>());
     private boolean tickingBlockEntities;
 
     // time
@@ -379,8 +384,8 @@ public final class RegionizedWorldData {
     public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public final Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public final Map<BlockPos, CraftBlockState> capturedBlockStates = Maps.newConcurrentMap(); // Paper
+    public final Map<BlockPos, BlockEntity> capturedTileEntities = Maps.newConcurrentMap(); // Paper
     public List<ItemEntity> captureDrops;
     // Paper start
     public int wakeupInactiveRemainingAnimals;
@@ -596,11 +601,8 @@ public final class RegionizedWorldData {
     }
 
     public void addEntityTickingEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         this.entityTickList.add(entity);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(entity);
     }
 
     public boolean hasEntityTickingEntity(final Entity entity) {
@@ -608,11 +610,8 @@ public final class RegionizedWorldData {
     }
 
     public void removeEntityTickingEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         this.entityTickList.remove(entity);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(entity);
     }
 
     public void forEachTickingEntity(final Consumer<Entity> action) {
@@ -627,15 +626,12 @@ public final class RegionizedWorldData {
     }
 
     public void addEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(this.world, entity.chunkPosition())) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
                 this.nearbyPlayers.addPlayer(player);
             }
-            TickRegions.RegionStats.updateCurrentRegion();
+            TickRegions.RegionStats.updateCurrentRegion(entity);
         }
     }
 
@@ -644,34 +640,25 @@ public final class RegionizedWorldData {
     }
 
     public void removeEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
                 this.nearbyPlayers.removePlayer(player);
             }
-            TickRegions.RegionStats.updateCurrentRegion();
+            TickRegions.RegionStats.updateCurrentRegion(entity);
         }
     }
 
     public void addNavigatingMob(final Mob mob) {
-        if (!TickThread.isTickThreadFor(mob)) {
-            throw new IllegalArgumentException("Entity " + mob + " is not under this region's control");
-        }
         this.navigatingMobs.add(mob);
     }
 
     public void removeNavigatingMob(final Mob mob) {
-        if (!TickThread.isTickThreadFor(mob)) {
-            throw new IllegalArgumentException("Entity " + mob + " is not under this region's control");
-        }
         this.navigatingMobs.remove(mob);
     }
 
-    public Iterator<Mob> getNavigatingMobs() {
-        return this.navigatingMobs.unsafeIterator();
+    public IteratorSafeOrderedReferenceSet<Mob> getNavigatingMobs() {
+        return this.navigatingMobs;
     }
 
     // block ticking hooks
@@ -744,12 +731,12 @@ public final class RegionizedWorldData {
     // ticking chunks
     public void addEntityTickingChunk(final LevelChunk levelChunk) {
         this.entityTickingChunks.add(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public void removeEntityTickingChunk(final LevelChunk levelChunk) {
         this.entityTickingChunks.remove(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public IteratorSafeOrderedReferenceSet<LevelChunk> getEntityTickingChunks() {
@@ -772,12 +759,12 @@ public final class RegionizedWorldData {
 
     public void addChunk(final LevelChunk levelChunk) {
         this.chunks.add(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public void removeChunk(final LevelChunk levelChunk) {
         this.chunks.remove(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public IteratorSafeOrderedReferenceSet<LevelChunk> getChunks() {
diff --git a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
index fd0053369eb68f0fd596d8acfba4a5247ef8105a..69b2f6182e135ba86ac878956aabfd472f103f11 100644
--- a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
@@ -640,6 +640,7 @@ public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegio
         // need to split the region, so we need to kill the old one first
         region.state = ThreadedRegion.STATE_DEAD;
         region.onRemove(true);
+        region.regioniser.world.regionizedWorldDataAccessor.removeRegion((ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>) region);
 
         // create new regions
         final Long2ReferenceOpenHashMap<ThreadedRegion<R, S>> newRegionsMap = new Long2ReferenceOpenHashMap<>();
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index ab5f832aafc479eca1c5da012e180d6374e32325..d4871db7c15e569ea6427e78b5e1e9e706e88f1f 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -210,9 +210,9 @@ public final class TickRegionScheduler {
 
     // By using our own thread object, we can use a field for the current region rather than a ThreadLocal.
     // This is much faster than a thread local, since the thread local has to use a map lookup.
-    private static final class TickThreadRunner extends TickThread {
+    public static final class TickThreadRunner extends TickThread {
 
-        private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
+        public ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion; //Make it public
         private RegionizedWorldData currentTickingWorldRegionizedData;
         private SchedulerThreadPool.SchedulableTick currentTickingTask;
         // Folia start - profiler
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index 78c50292fb25e8703e9c91db892f05456f07d72f..dfd565ff01bf6c396d7c6025206eb6e9b75e43a7 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -12,6 +12,8 @@ import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.slf4j.Logger;
 import java.util.Iterator;
 import java.util.concurrent.TimeUnit;
@@ -153,6 +155,28 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             this.chunkCount.setRelease(data == null ? 0 : data.getChunkCount());
         }
 
+        static void updateCurrentRegion(Entity entity) {
+            ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                    TickRegionScheduler.getCurrentRegion();
+
+            if (region == null){
+                region = ((ServerLevel) entity.level()).regioniser.getRegionAtUnsynchronised(entity.getBlockX() >> 4,entity.getBlockZ() >> 4);
+            }
+
+            region.getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+
+        static void updateCurrentRegion(LevelChunk chunk) {
+            ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                    TickRegionScheduler.getCurrentRegion();
+
+            if (region == null){
+                region = chunk.level.regioniser.getRegionAtUnsynchronised(chunk.locX,chunk.locZ);
+            }
+
+            region.getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+
         static void updateCurrentRegion() {
             TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
         }
@@ -213,11 +237,11 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             return this.holderManagerRegionData;
         }
 
-        <T> T getRegionizedData(final RegionizedData<T> regionizedData) {
+        public <T> T getRegionizedData(final RegionizedData<T> regionizedData) {
             return (T)this.regionizedData.get(regionizedData);
         }
 
-        <T> T getOrCreateRegionizedData(final RegionizedData<T> regionizedData) {
+        public <T> T getOrCreateRegionizedData(final RegionizedData<T> regionizedData) {
             T ret = (T)this.regionizedData.get(regionizedData);
 
             if (ret != null) {
@@ -227,6 +251,10 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             ret = regionizedData.createNewValue();
             this.regionizedData.put(regionizedData, ret);
 
+            if (ret instanceof RegionizedWorldData regionizedWorldData){
+                regionizedWorldData.world.regionizedWorldDataAccessor.updateWorldData(this.region,regionizedWorldData);
+            }
+
             return ret;
         }
 
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index 906f1c9e619a924c622acc76652a4569305edc8d..98fc618612feb1f119d00be1370b3ef6b7d0c5bc 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -18,6 +18,8 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class TickThread extends Thread {
@@ -38,7 +40,7 @@ public class TickThread extends Thread {
         if (!STRICT_THREAD_CHECKS) {
             return;
         }
-        ensureTickThread(reason);
+        //ensureTickThread(reason);
     }
 
     /**
@@ -47,50 +49,50 @@ public class TickThread extends Thread {
     @Deprecated
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+           // throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final BlockPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final ChunkPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final int chunkX, final int chunkZ, final String reason) {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
         if (!isTickThreadFor(entity)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final AABB aabb, final String reason) {
         if (!isTickThreadFor(world, aabb)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+           // throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final double blockX, final double blockZ, final String reason) {
         if (!isTickThreadFor(world, blockX, blockZ)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
diff --git a/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java b/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..a714c1a1443901913fb39634e97d49bc6319a24e
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java
@@ -0,0 +1,15 @@
+package me.earthme.lightingluminol;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+
+public class RegonizedWorldDataSwitcher {
+    private volatile RegionizedWorldData lastMatch = null;
+
+    public RegionizedWorldData getLastMatch(){
+        return this.lastMatch;
+    }
+
+    public void updateCurrent(RegionizedWorldData data){
+        this.lastMatch = data;
+    }
+}
diff --git a/src/main/java/me/earthme/lightingluminol/SchedulerUtil.java b/src/main/java/me/earthme/lightingluminol/SchedulerUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..e022464207f271e0f2047ec60ff593bc84bba6d9
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/SchedulerUtil.java
@@ -0,0 +1,31 @@
+package me.earthme.lightingluminol;
+
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.Supplier;
+
+public class SchedulerUtil {
+    public static final MinecraftInternalPlugin NULL_PLUG = new MinecraftInternalPlugin();
+
+    public static Executor regionSchedulerAsExecutor(int chunkX, int chunkZ, ServerLevel level){
+        return task -> Bukkit.getRegionScheduler().execute(NULL_PLUG,level.getWorld(),chunkX,chunkZ,task);
+    }
+
+    public static Executor regionSchedulerAsExecutor(World world,int x,int z){
+        return task -> Bukkit.getRegionScheduler().execute(NULL_PLUG,world,x,z,task);
+    }
+
+    public static boolean checkOnTargetScheduler(Location location){
+        return Bukkit.isOwnedByCurrentRegion(location);
+    }
+
+    public static <T> T ensureOnTargetRegion(World world,int x,int z,Supplier<T> act){
+        return CompletableFuture.supplyAsync(act,regionSchedulerAsExecutor(world,x,z)).join();
+    }
+}
diff --git a/src/main/java/me/earthme/lightingluminol/WorldDataAccessor.java b/src/main/java/me/earthme/lightingluminol/WorldDataAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..e308cf5af5dc9211b0ac1f5ad379817c5265656c
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/WorldDataAccessor.java
@@ -0,0 +1,129 @@
+package me.earthme.lightingluminol;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import io.papermc.paper.threadedregions.TickRegions;
+import io.papermc.paper.util.TickThread;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class WorldDataAccessor {
+    private final Level owner;
+    private final boolean ensureLoaded;
+    private final Map<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>,RegionizedWorldData> region2Data = new Reference2ObjectLinkedOpenHashMap<>();
+    private final ReadWriteLock accessLock = new ReentrantReadWriteLock();
+
+    public void removeRegion(ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region){
+        this.accessLock.writeLock().lock();
+        try {
+            this.region2Data.remove(region);
+        }finally {
+            this.accessLock.writeLock().unlock();
+        }
+    }
+
+    public void updateWorldData(ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region,RegionizedWorldData data) {
+        this.accessLock.writeLock().lock();
+        try {
+            if (!this.region2Data.containsKey(region)){
+                this.region2Data.put(region,data);
+                return;
+            }
+
+            this.region2Data.replace(region,data);
+        }finally {
+            this.accessLock.writeLock().unlock();
+        }
+    }
+
+    public RegionizedWorldData getDataOf(ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> key){
+        this.accessLock.readLock().lock();
+        try {
+            return this.region2Data.get(key);
+        }finally {
+            this.accessLock.readLock().unlock();
+        }
+    }
+
+    public WorldDataAccessor(Level owner, boolean ensureLoaded) {
+        this.owner = owner;
+        this.ensureLoaded = ensureLoaded;
+    }
+
+    public RegionizedWorldData getDirectly(int cposX,int cposZ){
+        final ServerLevel serverLevel = ((ServerLevel) this.owner);
+        ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> targetRegion = serverLevel.regioniser.getRegionAtUnsynchronised(cposX,cposZ);
+
+        if (targetRegion != null){
+            return this.getDataOf(targetRegion);
+        }
+
+        if (ensureLoaded && !TickThread.isTickThreadFor(serverLevel,cposX,cposZ)){
+            AtomicReference<RegionizedWorldData> result = new AtomicReference<>();
+
+            serverLevel.loadChunksAsync(cposX,cposX + 1,cposZ,cposZ + 1, PrioritisedExecutor.Priority.HIGHEST,callback -> {
+                result.set(serverLevel.getCurrentWorldData());
+            });
+
+            while (true){
+                if (result.get() != null){
+                    return result.get();
+                }
+            }
+        }else if (TickThread.isTickThreadFor(serverLevel,cposX,cposZ)){
+            return serverLevel.getCurrentWorldData();
+        }
+
+        return null;
+    }
+
+    public RegionizedWorldData getAnyCPos(int cposX,int cposZ){
+        final RegionizedWorldData current = this.owner.getCurrentWorldDataUnsafe();
+        final RegionizedWorldData got = getDirectly(cposX,cposZ);
+
+        if (current == null || current != got){
+            return got;
+        }
+
+        return current;
+    }
+
+    public RegionizedWorldData getAny(int x,int z){
+        return getAnyCPos(x >> 4,z >> 4);
+    }
+
+    public RegionizedWorldData getAny(ChunkPos cpos){
+        return getAnyCPos(cpos.x,cpos.z);
+    }
+
+    public RegionizedWorldData getAny(BlockPos pos){
+        return getAny(pos.getX(),pos.getZ());
+    }
+
+    public RegionizedWorldData getAny(Entity ent){
+        return getAny(ent.blockPosition.getX(),ent.blockPosition.getZ());
+    }
+
+    private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> getRegion(int cposX, int cposZ){
+        ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> result = ((ServerLevel) this.owner).regioniser.getRegionAtSynchronised(cposX,cposZ);
+
+        if (result != null){
+            return result;
+        }
+
+        return ((ServerLevel) this.owner).regioniser.getRegionAtUnsynchronised(cposX,cposZ);
+    }
+}
diff --git a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
index 2e701ff7dc2c04f77e2f003cae0416483b290217..e5e2e8e550d4be89d9bd653135bcc762fe9d1bc4 100644
--- a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -634,7 +634,7 @@ public interface DispenseItemBehavior {
                     }
                 }
 
-                io.papermc.paper.threadedregions.RegionizedWorldData worldData = worldserver.getCurrentWorldData(); // Folia - region threading
+                io.papermc.paper.threadedregions.RegionizedWorldData worldData = worldserver.regionizedWorldDataAccessor.getAny(pointer.pos()); // Folia - region threading
                 worldData.captureTreeGeneration = true; // Folia - region threading
                 // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index e169a9d4c2e633fdba3fe425e2f3f766d2200af5..15d780a12209e4378d4e28efbf6754f8fedae52b 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -189,7 +189,7 @@ import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
-
+import io.papermc.paper.threadedregions.RegionizedServer;
 import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable {
@@ -2290,7 +2290,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public int getTickCount() {
-        throw new UnsupportedOperationException(); // Folia - region threading
+        //throw new UnsupportedOperationException(); // Folia - region threading
+        return ((int) RegionizedServer.getGlobalTickData().getCurrentTick());
     }
 
     public int getSpawnProtectionRadius() {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index b7d91b7e8eb31f838cf540246f2d9b9c32b28780..f201154d3e2be73e12611cfa1427aef57418f301 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -309,7 +309,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         int index = entity.getType().getCategory().ordinal();
 
         final com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> inRange =
-            this.getNearbyPlayers().getPlayers(entity.chunkPosition(), io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
+            this.level.regionizedWorldDataAccessor.getAny(entity).getNearbyPlayers().getPlayers(entity.chunkPosition(), io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
         if (inRange == null) {
             return;
         }
@@ -326,7 +326,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
         int idx = mobCategory.ordinal();
         final com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> inRange =
-            this.getNearbyPlayers().getPlayersByChunk(chunkX, chunkZ, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
+            this.level.regionizedWorldDataAccessor.getAny(chunkX,chunkZ).getNearbyPlayers().getPlayersByChunk(chunkX, chunkZ, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
         if (inRange == null) {
             return;
         }
@@ -1063,7 +1063,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
                         this.updatePlayerStatus(entityplayer, true);
                         // Folia start - region threading
-                        for (Entity possible : this.level.getCurrentWorldData().getLoadedEntities()) {
+                        for (Entity possible : this.level.regionizedWorldDataAccessor.getAny(entity).getLoadedEntities()) {
                             if (possible.tracker != null) {
                                 possible.tracker.updatePlayer(entityplayer);
                             }
@@ -1081,7 +1081,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         if (entity instanceof ServerPlayer entityplayer) {
             this.updatePlayerStatus(entityplayer, false);
             // Folia start - region threading
-            for (Entity possible : this.level.getCurrentWorldData().getLocalEntities()) {
+            for (Entity possible : this.level.regionizedWorldDataAccessor.getAny(entity).getLocalEntities()) {
                 if (possible.tracker != null) {
                     possible.tracker.removePlayer(entityplayer);
                 }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 1cb09933aa4fa9f766c92ce000aed103fb2a5f54..6edd7209eacc1d6f0b27c96c59a85e9da88564f7 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -44,6 +44,10 @@ import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.util.TickThread;
+import me.earthme.lightingluminol.SchedulerUtil;
+
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -198,9 +202,9 @@ public class ServerChunkCache extends ChunkSource {
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
         if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
-            return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
+            return CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
-            }, this.mainThreadProcessor).join();
+            }, SchedulerUtil.regionSchedulerAsExecutor(this.level.getWorld(),x,z)).join();
         } else {
             // Paper start - Perf: Optimise getChunkAt calls for loaded chunks
             LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(x, z);
@@ -224,7 +228,11 @@ public class ServerChunkCache extends ChunkSource {
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.pushChunkWait(this.level, x1, z1); // Paper - rewrite chunk system
                 com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.level, x, z); // Paper - Add debug for sync chunk loads
                 this.level.timings.syncChunkLoad.startTiming(); // Paper
-            chunkproviderserver_b.managedBlock(completablefuture::isDone);
+                if (!RegionizedServer.isGlobalTickThread() || !TickThread.isTickThreadFor(this.level,x,z)){
+                    chunkproviderserver_b.managedBlock(completablefuture::isDone);
+                }else{
+                    completablefuture.join();
+                }
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - rewrite chunk system
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
             } // Paper
@@ -874,8 +882,10 @@ public class ServerChunkCache extends ChunkSource {
         // CraftBukkit start - process pending Chunk loadCallback() and unloadCallback() after each run task
         public boolean pollTask() {
             // Folia start - region threading
-            if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
-                throw new IllegalStateException("Polling tasks from non-owned region");
+            if (!RegionizedServer.isGlobalTickThread()){
+                if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
+                    throw new IllegalStateException("Polling tasks from non-owned region");
+                }
             }
             // Folia end - region threading
             if (ServerChunkCache.this.runDistanceManagerUpdates()) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 573cca66b905c5decb0e59c58cfa861d1788d5d3..e9678cf456a8ab5c75d56b5fe854fc356aa1eaaa 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -181,6 +181,7 @@ import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
+import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -620,7 +621,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     @Override
     public Player getNearestPlayer(double x, double y, double z, double maxDistance, @Nullable Predicate<Entity> targetPredicate) {
         if (maxDistance > 0.0D) {
-            io.papermc.paper.util.player.NearbyPlayers players = this.chunkSource.chunkMap.getNearbyPlayers();
+            io.papermc.paper.util.player.NearbyPlayers players = this.regionizedWorldDataAccessor.getAny((int) x, (int) z).getNearbyPlayers();
 
             com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> nearby = players.getPlayersByBlock(
                 io.papermc.paper.util.CoordinateUtils.getBlockCoordinate(x),
@@ -679,7 +680,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                                    double x, double y, double z) {
         double range = targetPredicate.range;
         if (range > 0.0D) {
-            io.papermc.paper.util.player.NearbyPlayers players = this.chunkSource.chunkMap.getNearbyPlayers();
+            io.papermc.paper.util.player.NearbyPlayers players = this.regionizedWorldDataAccessor.getAny(entity).getNearbyPlayers();
 
             com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> nearby = players.getPlayersByBlock(
                 io.papermc.paper.util.CoordinateUtils.getBlockCoordinate(x),
@@ -1888,10 +1889,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
             // WorldServer.LOGGER.warn("Tried to add entity {} but it was marked as removed already", EntityTypes.getKey(entity.getType())); // CraftBukkit
             return false;
         } else {
+            var got = ServerLevel.this.regionizedWorldDataAccessor.getAny(entity);
+
             if (entity instanceof net.minecraft.world.entity.item.ItemEntity itemEntity && itemEntity.getItem().isEmpty()) return false; // Paper - Prevent empty items from being added
             // Paper start - capture all item additions to the world
-            if (this.getCurrentWorldData().captureDrops != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) { // Folia - region threading
-                this.getCurrentWorldData().captureDrops.add((net.minecraft.world.entity.item.ItemEntity) entity); // Folia - region threading
+            if (got.captureDrops != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) { // Folia - region threading
+                got.captureDrops.add((net.minecraft.world.entity.item.ItemEntity) entity); // Folia - region threading
                 return true;
             }
             // Paper end - capture all item additions to the world
@@ -2053,7 +2056,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         this.getChunkSource().blockChanged(pos);
-        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - region threading
+        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.regionizedWorldDataAccessor.getAny(pos); // Folia - region threading
         regionizedWorldData.pathTypesByPosCache.invalidate(pos); // Folia - region threading
         if (this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
         VoxelShape voxelshape = oldState.getCollisionShape(this, pos);
@@ -2061,7 +2064,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = regionizedWorldData.getNavigatingMobs(); // Folia - region threading
+            Iterator iterator = regionizedWorldData.getNavigatingMobs().unsafeIterator(); // Folia - region threading
 
             while (iterator.hasNext()) {
                 // CraftBukkit start - fix SPIGOT-6362
@@ -2102,23 +2105,31 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block sourceBlock) {
-        if (this.getCurrentWorldData().captureBlockStates) { return; } // Paper - Cancel all physics during placement // Folia - region threading
-        this.getCurrentWorldData().neighborUpdater.updateNeighborsAtExceptFromFacing(pos, sourceBlock, (Direction) null); // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+
+        if (got.captureBlockStates) { return; } // Paper - Cancel all physics during placement // Folia - region threading
+        got.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, sourceBlock, (Direction) null); // Folia - region threading
     }
 
     @Override
     public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, Direction direction) {
-        this.getCurrentWorldData().neighborUpdater.updateNeighborsAtExceptFromFacing(pos, sourceBlock, direction); // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+
+        got.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, sourceBlock, direction); // Folia - region threading
     }
 
     @Override
     public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
-        this.getCurrentWorldData().neighborUpdater.neighborChanged(pos, sourceBlock, sourcePos); // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+
+        got.neighborUpdater.neighborChanged(pos, sourceBlock, sourcePos); // Folia - region threading
     }
 
     @Override
     public void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
-        this.getCurrentWorldData().neighborUpdater.neighborChanged(state, pos, sourceBlock, sourcePos, notify); // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+
+        got.neighborUpdater.neighborChanged(state, pos, sourceBlock, sourcePos, notify); // Folia - region threading
     }
 
     @Override
@@ -2164,7 +2175,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void blockEvent(BlockPos pos, Block block, int type, int data) {
-        this.getCurrentWorldData().pushBlockEvent(new BlockEventData(pos, block, type, data)); // Folia - regionised ticking
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+
+        got.pushBlockEvent(new BlockEventData(pos, block, type, data)); // Folia - regionised ticking
     }
 
     private void runBlockEvents() {
@@ -2693,9 +2706,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void blockUpdated(BlockPos pos, Block block) {
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+
         if (!this.isDebug()) {
             // CraftBukkit start
-            if (this.getCurrentWorldData().populating) { // Folia - region threading
+            if (got.populating) { // Folia - region threading
                 return;
             }
             // CraftBukkit end
@@ -2918,12 +2933,16 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         public void onTickingStart(Entity entity) {
+            var got = ServerLevel.this.regionizedWorldDataAccessor.getAny(entity);
+
             if (entity instanceof net.minecraft.world.entity.Marker && !paperConfig().entities.markers.tick) return; // Paper - Configurable marker ticking
-            ServerLevel.this.getCurrentWorldData().addEntityTickingEntity(entity); // Folia - region threading
+            got.addEntityTickingEntity(entity); // Folia - region threading
         }
 
         public void onTickingEnd(Entity entity) {
-            ServerLevel.this.getCurrentWorldData().removeEntityTickingEntity(entity); // Folia - region threading
+            var got = ServerLevel.this.regionizedWorldDataAccessor.getAny(entity);
+
+            got.removeEntityTickingEntity(entity); // Folia - region threading
             // Paper start - Reset pearls when they stop being ticked
             if (paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && entity instanceof net.minecraft.world.entity.projectile.ThrownEnderpearl pearl) {
                 pearl.cachedOwner = null;
@@ -2934,7 +2953,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         public void onTrackingStart(Entity entity) {
             org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
-            ServerLevel.this.getCurrentWorldData().addLoadedEntity(entity); // Folia - region threading
+            var got = ServerLevel.this.regionizedWorldDataAccessor.getAny(entity);
+
+            got.addLoadedEntity(entity); // Folia - region threading
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer entityplayer) {
                 ServerLevel.this.players.add(entityplayer);
@@ -2948,7 +2969,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.getCurrentWorldData().addNavigatingMob(entityinsentient); // Folia - region threading
+                got.addNavigatingMob(entityinsentient); // Folia - region threading
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
@@ -2982,7 +3003,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         public void onTrackingEnd(Entity entity) {
             org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
-            ServerLevel.this.getCurrentWorldData().removeLoadedEntity(entity);
+            var got = ServerLevel.this.regionizedWorldDataAccessor.getAny(entity);
+
+            got.removeLoadedEntity(entity);
             // Spigot start
             if ( entity instanceof Player )
             {
@@ -3040,7 +3063,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.getCurrentWorldData().removeNavigatingMob(entityinsentient); // Folia - region threading
+                got.removeNavigatingMob(entityinsentient); // Folia - region threading
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 990879f69e4ee37d6633c77ea31433736dd154f8..b7a5805e20a8fb1fbb65acd987b19fd73c12951c 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -419,7 +419,9 @@ public class ServerPlayerGameMode {
             } else {
                 // CraftBukkit start
                 org.bukkit.block.BlockState state = bblock.getState();
-                this.level.getCurrentWorldData().captureDrops = new ArrayList<>(); // Folia - region threading
+                var got = this.level.regionizedWorldDataAccessor.getAny(bblock.getX(),bblock.getZ());
+
+                got.captureDrops = new ArrayList<>(); // Folia - region threading
                 // CraftBukkit end
                 BlockState iblockdata1 = block.playerWillDestroy(this.level, pos, iblockdata, this.player);
                 boolean flag = this.level.removeBlock(pos, false);
@@ -447,8 +449,8 @@ public class ServerPlayerGameMode {
                     // return true; // CraftBukkit
                 }
                 // CraftBukkit start
-                java.util.List<net.minecraft.world.entity.item.ItemEntity> itemsToDrop = this.level.getCurrentWorldData().captureDrops; // Paper - capture all item additions to the world  // Folia - region threading
-                this.level.getCurrentWorldData().captureDrops = null; // Paper - capture all item additions to the world; Remove this earlier so that we can actually drop stuff  // Folia - region threading
+                java.util.List<net.minecraft.world.entity.item.ItemEntity> itemsToDrop = got.captureDrops; // Paper - capture all item additions to the world  // Folia - region threading
+                got.captureDrops = null; // Paper - capture all item additions to the world; Remove this earlier so that we can actually drop stuff  // Folia - region threading
                 if (event.isDropItems()) {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockDropItemEvent(bblock, state, this.player, itemsToDrop); // Paper - capture all item additions to the world
                 }
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index cc274fee6cd0a8b532ea2cf7be2876d9f5a708ee..83697752f69200f64ada063e3901c9520bf05537 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -167,7 +167,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
         }
         updateFuture.isTicketAdded = true;
 
-        final int references = this.chunkMap.level.getCurrentWorldData().chunksBeingWorkedOn.addTo(key, 1); // Folia - region threading
+        final int references = this.chunkMap.level.regionizedWorldDataAccessor.getAnyCPos(chunkX,chunkZ).chunksBeingWorkedOn.addTo(key, 1); // Folia - region threading
         if (references == 0) {
             final ChunkPos pos = new ChunkPos(chunkX, chunkZ);
             world.getChunkSource().addRegionTicket(ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET, pos, 0, pos);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 00d801aa1ffce0ccd8e7176f614d831ae09259d3..c32a75d3114be4100eed659c5e83b5552a0b0f65 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -161,6 +161,8 @@ import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
 // CraftBukkit end
+import org.bukkit.event.player.PlayerPortalEvent;
+import io.papermc.paper.util.MCUtil;
 
 public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, CommandSource, ScoreHolder {
 
@@ -4094,7 +4096,15 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         if (!this.canTeleportAsync()) {
             return false;
         }
-        this.getBukkitEntity(); // force bukkit entity to be created before TPing
+
+        final org.bukkit.entity.Entity bukkitEntity = this.getBukkitEntity(); // force bukkit entity to be created before TPing
+
+        if (!this.preventMoving && this instanceof ServerPlayer) {
+            if (!new PlayerTeleportEvent((org.bukkit.entity.Player) bukkitEntity,bukkitEntity.getLocation(), MCUtil.toLocation(destination,pos)).callEvent()){
+                return false;
+            }
+        }
+
         if ((teleportFlags & TELEPORT_FLAG_UNMOUNT) == 0L) {
             for (Entity entity : this.getIndirectPassengers()) {
                 if (!entity.canTeleportAsync()) {
@@ -4528,6 +4538,21 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 // we just have to abandon this teleport to prevent duplication
                 return;
             }
+
+            if (this instanceof ServerPlayer){
+                final org.bukkit.entity.Player bukkitPlayer = ((ServerPlayer) this).getBukkitEntity();
+                PlayerTeleportEvent.TeleportCause cause = PlayerTeleportEvent.TeleportCause.UNKNOWN;
+
+                switch (type){
+                    case END -> cause = PlayerTeleportEvent.TeleportCause.END_PORTAL;
+                    case NETHER -> cause = PlayerTeleportEvent.TeleportCause.NETHER_PORTAL;
+                }
+
+                final PlayerPortalEvent eventWrapped = new PlayerPortalEvent(bukkitPlayer,MCUtil.toLocation(originWorld,initialPosition),MCUtil.toLocation(destination,info.pos),cause,0,true, 0);
+                eventWrapped.callEvent();
+                info.pos = MCUtil.toVec3(eventWrapped.getTo());
+            }
+
             originWorld.chunkSource.removeTicketAtLevel(
                 TicketType.TELEPORT_HOLD_TICKET, initialPositionChunk,
                 io.papermc.paper.chunk.system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
diff --git a/src/main/java/net/minecraft/world/entity/projectile/Projectile.java b/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
index cd133931de618e5d8ed5062f8ebfde9d8a9e799c..a03cf8f8be5afcc3e9f251e868e52406858a173f 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
@@ -4,6 +4,8 @@ import com.google.common.base.MoreObjects;
 import java.util.Iterator;
 import java.util.UUID;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.threadedregions.TickRegionScheduler;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.nbt.CompoundTag;
@@ -53,23 +55,25 @@ public abstract class Projectile extends Entity implements TraceableEntity {
     private int loadedLifetime = 0;
     @Override
     public void setPos(double x, double y, double z) {
-        long currentTick = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion().getData().getCurrentTick();
-        if (loadedTick != currentTick) {
-            loadedTick = currentTick;
-            loadedThisTick = 0;
-        }
-        int previousX = Mth.floor(this.getX()) >> 4, previousZ = Mth.floor(this.getZ()) >> 4;
-        int newX = Mth.floor(x) >> 4, newZ = Mth.floor(z) >> 4;
-        if (previousX != newX || previousZ != newZ) {
-            boolean isLoaded = ((net.minecraft.server.level.ServerChunkCache) this.level().getChunkSource()).getChunkAtIfLoadedMainThread(newX, newZ) != null;
-            if (!isLoaded) {
-                if (Projectile.loadedThisTick > me.earthme.luminol.config.modules.optimizations.ProjectileChunkReduceConfig.maxProjectileLoadsPerTick) {
-                    if (++this.loadedLifetime > me.earthme.luminol.config.modules.optimizations.ProjectileChunkReduceConfig.maxProjectileLoadsPerProjectile) {
-                        this.discard();
+        if (TickRegionScheduler.getCurrentRegion() != null){
+            long currentTick = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion().getData().getCurrentTick();
+            if (loadedTick != currentTick) {
+                loadedTick = currentTick;
+                loadedThisTick = 0;
+            }
+            int previousX = Mth.floor(this.getX()) >> 4, previousZ = Mth.floor(this.getZ()) >> 4;
+            int newX = Mth.floor(x) >> 4, newZ = Mth.floor(z) >> 4;
+            if (previousX != newX || previousZ != newZ) {
+                boolean isLoaded = ((net.minecraft.server.level.ServerChunkCache) this.level().getChunkSource()).getChunkAtIfLoadedMainThread(newX, newZ) != null;
+                if (!isLoaded) {
+                    if (Projectile.loadedThisTick > me.earthme.luminol.config.modules.optimizations.ProjectileChunkReduceConfig.maxProjectileLoadsPerTick) {
+                        if (++this.loadedLifetime > me.earthme.luminol.config.modules.optimizations.ProjectileChunkReduceConfig.maxProjectileLoadsPerProjectile) {
+                            this.discard();
+                        }
+                        return;
                     }
-                    return;
+                    Projectile.loadedThisTick++;
                 }
-                Projectile.loadedThisTick++;
             }
         }
         super.setPos(x, y, z);
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 8c124cb3d1238c9f3297f9f2d2345399055147fe..6ee2616cbe6362a3ae950133a7dfaf810d07f874 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -10,6 +10,9 @@ import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+import me.earthme.lightingluminol.WorldDataAccessor;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -211,11 +214,25 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     );
     public volatile io.papermc.paper.threadedregions.RegionizedServer.WorldLevelData tickData;
     public final java.util.concurrent.ConcurrentHashMap.KeySetView<net.minecraft.server.level.ChunkHolder, Boolean> needsChangeBroadcasting = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    public WorldDataAccessor regionizedWorldDataAccessor = new WorldDataAccessor(this,false);
+
+    public io.papermc.paper.threadedregions.RegionizedWorldData getCurrentWorldDataUnsafe() {
+        final io.papermc.paper.threadedregions.RegionizedWorldData ret = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
+        if (ret == null) {
+            return null;
+        }
+        Level world = ret.world;
+        if (world != this) {
+            return null;
+        }
+        return ret;
+    }
+
 
     public io.papermc.paper.threadedregions.RegionizedWorldData getCurrentWorldData() {
         final io.papermc.paper.threadedregions.RegionizedWorldData ret = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
         if (ret == null) {
-            return ret;
+            return null;
         }
         Level world = ret.world;
         if (world != this) {
@@ -864,8 +881,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     @Nullable
     public final BlockState getBlockStateIfLoaded(BlockPos pos) {
         // CraftBukkit start - tree generation
-        if (this.getCurrentWorldData().captureTreeGeneration) { // Folia - region threading
-            CraftBlockState previous = this.getCurrentWorldData().capturedBlockStates.get(pos); // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+        if (got.captureTreeGeneration) { // Folia - region threading
+            CraftBlockState previous = got.capturedBlockStates.get(pos); // Folia - region threading
             if (previous != null) {
                 return previous.getHandle();
             }
@@ -928,7 +946,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     @Override
     public boolean setBlock(BlockPos pos, BlockState state, int flags, int maxUpdateDepth) {
         io.papermc.paper.util.TickThread.ensureTickThread((ServerLevel)this, pos, "Updating block asynchronously"); // Folia - region threading
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.getCurrentWorldData(); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.regionizedWorldDataAccessor.getAny(pos); // Folia - region threading
         // CraftBukkit start - tree generation
         if (worldData.captureTreeGeneration) { // Folia - region threading
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
@@ -1049,6 +1067,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 }
             }
 
+            var worlddata = this.regionizedWorldDataAccessor.getAny(blockposition);
+
             if ((i & 16) == 0 && j > 0) {
                 int k = i & -34;
 
@@ -1056,7 +1076,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 iblockdata1.updateIndirectNeighbourShapes(this, blockposition, k, j - 1); // Don't call an event for the old block to limit event spam
                 CraftWorld world = ((ServerLevel) this).getWorld();
                 boolean cancelledUpdates = false; // Paper - Fix block place logic
-                if (world != null && ((ServerLevel)this).getCurrentWorldData().hasPhysicsEvent) { // Paper - BlockPhysicsEvent // Folia - region threading
+                if (world != null && worlddata.hasPhysicsEvent) { // Paper - BlockPhysicsEvent // Folia - region threading
                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftBlockData.fromData(iblockdata));
                     this.getCraftServer().getPluginManager().callEvent(event);
 
@@ -1070,7 +1090,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             }
 
             // CraftBukkit start - SPIGOT-5710
-            if (!this.getCurrentWorldData().preventPoiUpdated) { // Folia - region threading
+            if (!worlddata.preventPoiUpdated) { // Folia - region threading
                 this.onBlockStateChange(blockposition, iblockdata1, iblockdata2);
             }
             // CraftBukkit end
@@ -1154,7 +1174,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
     @Override
     public void neighborShapeChanged(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
-        this.getCurrentWorldData().neighborUpdater.shapeUpdate(direction, neighborState, pos, neighborPos, flags, maxUpdateDepth); // Folia - region threading
+        this.regionizedWorldDataAccessor.getAny(pos).neighborUpdater.shapeUpdate(direction, neighborState, pos, neighborPos, flags, maxUpdateDepth); // Folia - region threading
     }
 
     @Override
@@ -1205,8 +1225,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     @Override
     public BlockState getBlockState(BlockPos pos) {
         // CraftBukkit start - tree generation
-        if (this.getCurrentWorldData().captureTreeGeneration) { // Folia - region threading
-            CraftBlockState previous = this.getCurrentWorldData().capturedBlockStates.get(pos); // Paper // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(pos);
+        if (got.captureTreeGeneration) { // Folia - region threading
+            CraftBlockState previous = got.capturedBlockStates.get(pos); // Paper // Folia - region threading
             if (previous != null) {
                 return previous.getHandle();
             }
@@ -1301,7 +1322,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
 
     public void addBlockEntityTicker(TickingBlockEntity ticker) {
-        ((ServerLevel)this).getCurrentWorldData().addBlockEntityTicker(ticker); // Folia - regionised ticking
+        this.regionizedWorldDataAccessor.getAny(ticker.getPos()).addBlockEntityTicker(ticker); // Folia - regionised ticking
     }
 
     protected void tickBlockEntities() {
@@ -1478,7 +1499,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         // Folia end - region threading
         // Paper start - Perf: Optimize capturedTileEntities lookup
         net.minecraft.world.level.block.entity.BlockEntity blockEntity;
-        if (!this.getCurrentWorldData().capturedTileEntities.isEmpty() && (blockEntity = this.getCurrentWorldData().capturedTileEntities.get(blockposition)) != null) { // Folia - region threading
+        var got = this.regionizedWorldDataAccessor.getAny(blockposition);
+        if (!got.capturedTileEntities.isEmpty() && (blockEntity = got.capturedTileEntities.get(blockposition)) != null) { // Folia - region threading
             return blockEntity;
         }
         // Paper end - Perf: Optimize capturedTileEntities lookup
@@ -1489,10 +1511,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public void setBlockEntity(BlockEntity blockEntity) {
         BlockPos blockposition = blockEntity.getBlockPos();
 
+        var got = this.regionizedWorldDataAccessor.getAny(blockposition);
         if (!this.isOutsideBuildHeight(blockposition)) {
             // CraftBukkit start
-            if (this.getCurrentWorldData().captureBlockStates) { // Folia - region threading
-                this.getCurrentWorldData().capturedTileEntities.put(blockposition.immutable(), blockEntity); // Folia - region threading
+            if (got.captureBlockStates) { // Folia - region threading
+                got.capturedTileEntities.put(blockposition.immutable(), blockEntity); // Folia - region threading
                 return;
             }
             // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index b266cc2319177366471ee0bbf570a931974b642a..721103971dfa5260f63b7b4b733e3933707f75eb 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -390,8 +390,9 @@ public class Block extends BlockBehaviour implements ItemLike {
 
             entityitem.setDefaultPickUpDelay();
             // CraftBukkit start
-            if (world.getCurrentWorldData().captureDrops != null) { // Folia - region threading
-                world.getCurrentWorldData().captureDrops.add(entityitem); // Folia - region threading
+            var got = world.regionizedWorldDataAccessor.getAny(entityitem);
+            if (got.captureDrops != null) { // Folia - region threading
+                got.captureDrops.add(entityitem); // Folia - region threading
             } else {
                 world.addFreshEntity(entityitem);
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index c15be74b855a7c62f23499143634057e2ac27b7a..b1a85a6f1b3b0b39d2bca73d6105fde777d6a6b0 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -470,8 +470,10 @@ public class LevelChunk extends ChunkAccess {
                 if (!chunksection.getBlockState(j, k, l).is(block)) {
                     return null;
                 } else {
+                    var got = this.level.regionizedWorldDataAccessor.getAny(blockposition);
+
                     // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
-                    if (!this.level.isClientSide && doPlace && (!this.level.getCurrentWorldData().captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // Folia - region threading
+                    if (!this.level.isClientSide && doPlace && (!got.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // Folia - region threading
                         iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                     }
 
@@ -517,7 +519,8 @@ public class LevelChunk extends ChunkAccess {
     @Nullable
     public BlockEntity getBlockEntity(BlockPos pos, LevelChunk.EntityCreationType creationType) {
         // CraftBukkit start
-        BlockEntity tileentity = this.level.getCurrentWorldData().capturedTileEntities.get(pos); // Folia - region threading
+        var got = this.level.regionizedWorldDataAccessor.getAny(pos);
+        BlockEntity tileentity = got.capturedTileEntities.get(pos); // Folia - region threading
         if (tileentity == null) {
             tileentity = (BlockEntity) this.blockEntities.get(pos);
         }
@@ -805,13 +808,15 @@ public class LevelChunk extends ChunkAccess {
 
                 org.bukkit.World world = this.level.getWorld();
                 if (world != null) {
-                    this.level.getCurrentWorldData().populating = true; // Folia - region threading
+                    var got = this.level.regionizedWorldDataAccessor.getAnyCPos(this.chunkPos.x,this.chunkPos.z);
+
+                    got.populating = true; // Folia - region threading
                     try {
                         for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
                             populator.populate(world, random, bukkitChunk);
                         }
                     } finally {
-                        this.level.getCurrentWorldData().populating = false; // Folia - region threading
+                        got.populating = false; // Folia - region threading
                     }
                 }
                 server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
diff --git a/src/main/java/net/minecraft/world/level/portal/PortalInfo.java b/src/main/java/net/minecraft/world/level/portal/PortalInfo.java
index 34c0d9fe03cc834e949889f9c4f8269206c18040..4953371d205a1c3982a29252a51dcc99b1f5e99a 100644
--- a/src/main/java/net/minecraft/world/level/portal/PortalInfo.java
+++ b/src/main/java/net/minecraft/world/level/portal/PortalInfo.java
@@ -7,7 +7,7 @@ import org.bukkit.craftbukkit.event.CraftPortalEvent;
 
 public class PortalInfo {
 
-    public final Vec3 pos;
+    public Vec3 pos;
     public final Vec3 speed;
     public final float yRot;
     public final float xRot;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 273c37b63df3f14488586f9217c7b19a8f3d8ad5..cacae3b7c54b62e9cc54cb72f813db327f4ea334 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -262,6 +262,10 @@ import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
+import io.papermc.paper.threadedregions.RegionizedServer;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
+import static org.bukkit.craftbukkit.scheduler.CraftScheduler.MINECRAFT;
 
 public final class CraftServer implements Server {
     private final String serverName = io.papermc.paper.ServerBuildInfo.buildInfo().brandName(); // Paper
@@ -1270,7 +1274,6 @@ public final class CraftServer implements Server {
 
     @Override
     public World createWorld(WorldCreator creator) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         Preconditions.checkState(this.console.getAllLevels().iterator().hasNext(), "Cannot create additional worlds on STARTUP");
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot create a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         Preconditions.checkArgument(creator != null, "WorldCreator cannot be null");
@@ -1435,7 +1438,17 @@ public final class CraftServer implements Server {
         }
 
         this.console.addLevel(internal); // Paper - Put world into worldlist before initing the world; move up
-        this.console.initWorld(internal, worlddata, worlddata, worlddata.worldGenOptions());
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(internal);
+        int loadRegionRadius = ((32) >> 4);
+        internal.randomSpawnSelection = new net.minecraft.world.level.ChunkPos(internal.getChunkSource().randomState().sampler().findSpawnPosition());
+        for (int currX = -loadRegionRadius; currX <= loadRegionRadius; ++currX) {
+            for (int currZ = -loadRegionRadius; currZ <= loadRegionRadius; ++currZ) {
+                net.minecraft.world.level.ChunkPos pos = new net.minecraft.world.level.ChunkPos(currX, currZ);
+                internal.chunkSource.addTicketAtLevel(
+                        TicketType.UNKNOWN, pos, io.papermc.paper.chunk.system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, pos
+                );
+            }
+        }
 
         internal.setSpawnSettings(true, true);
         // Paper - Put world into worldlist before initing the world; move up
@@ -1453,7 +1466,7 @@ public final class CraftServer implements Server {
 
     @Override
     public boolean unloadWorld(World world, boolean save) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
+        //if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot unload a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         if (world == null) {
             return false;
@@ -1481,13 +1494,40 @@ public final class CraftServer implements Server {
         }
 
         try {
-            if (save) {
-                handle.save(null, true, false); // Paper - Fix saving in unloadWorld
-            }
+            if (RegionizedServer.isGlobalTickThread()) {
+                try {
+                    if (save) {
+                        handle.save(null, true, false); // Paper - don't disable saving
+                    }
 
-            handle.getChunkSource().close(save);
-            // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
-            handle.convertable.close();
+                    handle.getChunkSource().close(save);
+                    // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
+                    handle.convertable.close();
+                } catch (Exception ex) {
+                    this.getLogger().log(Level.SEVERE, null, ex);
+                }
+            } else {
+                final AtomicBoolean finished = new AtomicBoolean(false);
+                Bukkit.getGlobalRegionScheduler().run(MINECRAFT, t -> {
+                    try {
+                        if (save) {
+                            handle.save(null, true, false); // Paper - don't disable saving
+                        }
+
+                        handle.getChunkSource().close(save);
+                        // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
+                        handle.convertable.close();
+                    } catch (Exception ex) {
+                        this.getLogger().log(Level.SEVERE, null, ex);
+                    } finally {
+                        finished.set(true);
+                    }
+                });
+
+                while (!finished.get()) {
+                    LockSupport.parkNanos(1_000_000L);
+                }
+            }
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 0e549bfbecc15befc129a0382e189ba8cdd74c87..8a09e2a1f31c14a0c0d4b7e0446006d6a990d4a0 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -147,6 +147,7 @@ import org.bukkit.util.StructureSearchResult;
 import org.bukkit.util.Vector;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import net.minecraft.world.level.Level;
 
 public class CraftWorld extends CraftRegionAccessor implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -393,7 +394,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public boolean isChunkGenerated(int x, int z) {
         // Paper start - Fix this method
-        if (!io.papermc.paper.util.TickThread.isTickThreadFor(this.getHandle(), x, z)) { // Folia - region threading
+        if (!io.papermc.paper.util.TickThread.isTickThreadFor(this.getHandle(), x, z) && !io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread()) { // Folia - region threading
             return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
                 return CraftWorld.this.isChunkGenerated(x, z);
             }, (run) -> { io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(this.getHandle(), x, z, run);}).join(); // Folia - region threading
@@ -505,7 +506,11 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 },
                 list
             );
-            serverChunkCache.mainThreadProcessor.managedBlock(future::isDone);
+            if (!io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread()) {
+                serverChunkCache.mainThreadProcessor.managedBlock(future::isDone);
+            }else{
+                future.join();
+            }
             if (chunkStatus == ChunkStatus.NOISE) {
                 net.minecraft.world.level.levelgen.Heightmap.primeHeightmaps(future.join(), ChunkStatus.POST_FEATURES);
             }
@@ -846,7 +851,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
         io.papermc.paper.util.TickThread.ensureTickThread(this.world, loc.getX(), loc.getZ(), "Cannot generate tree asynchronously"); // Folia - region threading
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.regionizedWorldDataAccessor.getAny(loc.getBlockX(),loc.getBlockZ()); // Folia - region threading
         worldData.captureTreeGeneration = true; // Folia - region threading
         worldData.captureBlockStates = true; // Folia - region threading
         boolean grownTree = this.generateTree(loc, type);
@@ -898,7 +903,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setTime(long time) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
         long margin = (time - this.getFullTime()) % 24000;
         if (margin < 0) margin += 24000;
         this.setFullTime(this.getFullTime() + margin);
@@ -911,7 +916,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setFullTime(long time) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
         // Notify anyone who's listening
         TimeSkipEvent event = new TimeSkipEvent(this, TimeSkipEvent.SkipReason.CUSTOM, time - this.world.getDayTime());
         this.server.getPluginManager().callEvent(event);
@@ -1393,7 +1398,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setStorm(boolean hasStorm) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setRaining(hasStorm, org.bukkit.event.weather.WeatherChangeEvent.Cause.PLUGIN); // Paper - Add cause to Weather/ThunderChangeEvents
         this.setWeatherDuration(0); // Reset weather duration (legacy behaviour)
         this.setClearWeatherDuration(0); // Reset clear weather duration (reset "/weather clear" commands)
@@ -1406,7 +1411,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setWeatherDuration(int duration) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setRainTime(duration);
     }
 
@@ -1417,7 +1422,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setThundering(boolean thundering) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setThundering(thundering, org.bukkit.event.weather.ThunderChangeEvent.Cause.PLUGIN); // Paper - Add cause to Weather/ThunderChangeEvents
         this.setThunderDuration(0); // Reset weather duration (legacy behaviour)
         this.setClearWeatherDuration(0); // Reset clear weather duration (reset "/weather clear" commands)
@@ -1430,7 +1435,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setThunderDuration(int duration) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setThunderTime(duration);
     }
 
@@ -1441,7 +1446,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setClearWeatherDuration(int duration) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setClearWeatherTime(duration);
     }
 
@@ -1636,7 +1641,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setKeepSpawnInMemory(boolean keepLoaded) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify keep spawn in memory off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify keep spawn in memory off of the global region"); // Folia - region threading
         if (keepLoaded) {
             this.setGameRule(GameRule.SPAWN_CHUNK_RADIUS, this.getGameRuleDefault(GameRule.SPAWN_CHUNK_RADIUS));
         } else {
@@ -1705,7 +1710,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setHardcore(boolean hardcore) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.world.serverLevelData.settings.hardcore = hardcore;
     }
 
@@ -1718,7 +1723,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.ANIMAL, ticksPerAnimalSpawns);
     }
 
@@ -1731,7 +1736,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.MONSTER, ticksPerMonsterSpawns);
     }
 
@@ -1744,7 +1749,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_ANIMAL, ticksPerWaterSpawns);
     }
 
@@ -1757,7 +1762,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterAmbientSpawns(int ticksPerWaterAmbientSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_AMBIENT, ticksPerWaterAmbientSpawns);
     }
 
@@ -1770,7 +1775,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_UNDERGROUND_CREATURE, ticksPerWaterUndergroundCreatureSpawns);
     }
 
@@ -1783,13 +1788,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.AMBIENT, ticksPerAmbientSpawns);
     }
 
     @Override
     public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(spawnCategory != null, "SpawnCategory cannot be null");
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory.%s are not supported", spawnCategory);
 
@@ -1806,25 +1811,25 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
         this.server.getWorldMetadata().setMetadata(this, metadataKey, newMetadataValue);
     }
 
     @Override
     public List<MetadataValue> getMetadata(String metadataKey) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
         return this.server.getWorldMetadata().getMetadata(this, metadataKey);
     }
 
     @Override
     public boolean hasMetadata(String metadataKey) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
         return this.server.getWorldMetadata().hasMetadata(this, metadataKey);
     }
 
     @Override
     public void removeMetadata(String metadataKey, Plugin owningPlugin) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
         this.server.getWorldMetadata().removeMetadata(this, metadataKey, owningPlugin);
     }
 
@@ -1837,7 +1842,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setMonsterSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.MONSTER, limit);
     }
 
@@ -1850,7 +1855,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setAnimalSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.ANIMAL, limit);
     }
 
@@ -1863,7 +1868,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterAnimalSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_ANIMAL, limit);
     }
 
@@ -1876,7 +1881,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterAmbientSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_AMBIENT, limit);
     }
 
@@ -1889,7 +1894,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterUndergroundCreatureSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_UNDERGROUND_CREATURE, limit);
     }
 
@@ -1902,7 +1907,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setAmbientSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.AMBIENT, limit);
     }
 
@@ -1925,7 +1930,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(spawnCategory != null, "SpawnCategory cannot be null");
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory.%s are not supported", spawnCategory);
 
@@ -2109,7 +2114,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean setGameRuleValue(String rule, String value) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         // No null values allowed
         if (rule == null || value == null) return false;
 
@@ -2152,7 +2157,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(rule != null, "GameRule cannot be null");
         Preconditions.checkArgument(newValue != null, "GameRule value cannot be null");
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index 9efe9fce59a0b4fe7315dc41d1e21615b97e5cf6..3a2f3320dfdfdaf8a18470eadd64707b586f4665 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -15,6 +15,7 @@ import net.minecraft.world.item.BoneMealItem;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.block.Blocks;
@@ -598,7 +599,7 @@ public class CraftBlock implements Block {
         ServerLevel world = this.getCraftWorld().getHandle();
         UseOnContext context = new UseOnContext(world, null, InteractionHand.MAIN_HAND, Items.BONE_MEAL.getDefaultInstance(), new BlockHitResult(Vec3.ZERO, direction, this.getPosition(), false));
 
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.regionizedWorldDataAccessor.getAny(this.position); // Folia - region threading
         // SPIGOT-6895: Call StructureGrowEvent and BlockFertilizeEvent
         worldData.captureTreeGeneration = true; // Folia - region threading
         InteractionResult result = BoneMealItem.applyBonemeal(context);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index ae53333f8ebffea8874259495026484b003d1ad9..a40de83c307949a48bd0c001c0b9dfc2b5c64f44 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1396,7 +1396,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public boolean teleport(Location location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
         // Folia start - region threading
         if (true) {
-            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+            //throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+            return teleportAsync(location,cause).join();
         }
         // Folia end - region threading
         Set<io.papermc.paper.entity.TeleportFlag.Relative> relativeArguments;
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index b00e3b9b628f3d2a2fdbf1d2c77904963c16d3ac..e840a61bb05565db017532b10dd311ff7bc0b588 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -47,7 +47,7 @@ import org.bukkit.scheduler.BukkitWorker;
  */
 public class CraftScheduler implements BukkitScheduler {
 
-    static Plugin MINECRAFT = new MinecraftInternalPlugin();
+    public static Plugin MINECRAFT = new MinecraftInternalPlugin();
     /**
      * The start ID for the counter.
      */
@@ -109,8 +109,9 @@ public class CraftScheduler implements BukkitScheduler {
         }
     };
     private CraftAsyncDebugger debugTail = this.debugHead;
-
     */ // Paper end
+    //Molia start - For datapack command
+
     private static final int RECENT_TICKS;
 
     static {
@@ -532,7 +533,7 @@ public class CraftScheduler implements BukkitScheduler {
     }
 
     protected CraftTask handle(final CraftTask task, final long delay) { // Paper
-        if (true) throw new UnsupportedOperationException(); // Folia - region threading
+        //if (true) throw new UnsupportedOperationException(); // Folia - region threading //Molia - Disable this to support bukkit plugins
         // Paper start
         if (!this.isAsyncScheduler && !task.isSync()) {
             this.asyncScheduler.handle(task, delay);
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
index ce8b91f00f925960ad17f381162a11294e8b511d..506a8edda4fbf710b36919806ceb39b708641e37 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
@@ -44,8 +44,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
         return this.registerNewObjective(name, criteria, displayName, RenderType.INTEGER);
     }
     @Override
-    public CraftObjective registerNewObjective(String name, Criteria criteria, net.kyori.adventure.text.Component displayName, RenderType renderType) throws IllegalArgumentException {
-        if (true) throw new UnsupportedOperationException(); // Folia - not supported yet
+    public synchronized CraftObjective registerNewObjective(String name, Criteria criteria, net.kyori.adventure.text.Component displayName, RenderType renderType) throws IllegalArgumentException {
         if (displayName == null) {
             displayName = net.kyori.adventure.text.Component.empty();
         }
@@ -86,14 +85,14 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Objective getObjective(String name) {
+    public synchronized Objective getObjective(String name) {
         Preconditions.checkArgument(name != null, "Objective name cannot be null");
         net.minecraft.world.scores.Objective nms = this.board.getObjective(name);
         return nms == null ? null : new CraftObjective(this, nms);
     }
 
     @Override
-    public ImmutableSet<Objective> getObjectivesByCriteria(String criteria) {
+    public synchronized ImmutableSet<Objective> getObjectivesByCriteria(String criteria) {
         Preconditions.checkArgument(criteria != null, "Criteria name cannot be null");
 
         ImmutableSet.Builder<Objective> objectives = ImmutableSet.builder();
@@ -107,7 +106,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Objective> getObjectivesByCriteria(Criteria criteria) {
+    public synchronized ImmutableSet<Objective> getObjectivesByCriteria(Criteria criteria) {
         Preconditions.checkArgument(criteria != null, "Criteria cannot be null");
 
         ImmutableSet.Builder<Objective> objectives = ImmutableSet.builder();
@@ -122,12 +121,12 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Objective> getObjectives() {
+    public synchronized ImmutableSet<Objective> getObjectives() {
         return ImmutableSet.copyOf(Iterables.transform(this.board.getObjectives(), (Function<net.minecraft.world.scores.Objective, Objective>) input -> new CraftObjective(CraftScoreboard.this, input)));
     }
 
     @Override
-    public Objective getObjective(DisplaySlot slot) {
+    public synchronized Objective getObjective(DisplaySlot slot) {
         Preconditions.checkArgument(slot != null, "Display slot cannot be null");
         net.minecraft.world.scores.Objective objective = this.board.getDisplayObjective(CraftScoreboardTranslations.fromBukkitSlot(slot));
         if (objective == null) {
@@ -142,7 +141,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Score> getScores(String entry) {
+    public synchronized ImmutableSet<Score> getScores(String entry) {
         return this.getScores(CraftScoreboard.getScoreHolder(entry));
     }
 
@@ -162,7 +161,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public void resetScores(String entry) {
+    public synchronized void resetScores(String entry) {
         this.resetScores(CraftScoreboard.getScoreHolder(entry));
     }
 
@@ -175,7 +174,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Team getPlayerTeam(OfflinePlayer player) {
+    public synchronized Team getPlayerTeam(OfflinePlayer player) {
         Preconditions.checkArgument(player != null, "OfflinePlayer cannot be null");
 
         PlayerTeam team = this.board.getPlayersTeam(player.getName());
@@ -183,7 +182,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Team getEntryTeam(String entry) {
+    public synchronized Team getEntryTeam(String entry) {
         Preconditions.checkArgument(entry != null, "Entry cannot be null");
 
         PlayerTeam team = this.board.getPlayersTeam(entry);
@@ -191,7 +190,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Team getTeam(String teamName) {
+    public synchronized Team getTeam(String teamName) {
         Preconditions.checkArgument(teamName != null, "Team name cannot be null");
 
         PlayerTeam team = this.board.getPlayerTeam(teamName);
@@ -199,13 +198,12 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Team> getTeams() {
+    public synchronized ImmutableSet<Team> getTeams() {
         return ImmutableSet.copyOf(Iterables.transform(this.board.getPlayerTeams(), (Function<PlayerTeam, Team>) input -> new CraftTeam(CraftScoreboard.this, input)));
     }
 
     @Override
-    public Team registerNewTeam(String name) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not supported yet
+    public synchronized Team registerNewTeam(String name) {
         Preconditions.checkArgument(name != null, "Team name cannot be null");
         Preconditions.checkArgument(name.length() <= Short.MAX_VALUE, "Team name '%s' is longer than the limit of 32767 characters (%s)", name, name.length());
         Preconditions.checkArgument(this.board.getPlayerTeam(name) == null, "Team name '%s' is already in use", name);
@@ -214,7 +212,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<OfflinePlayer> getPlayers() {
+    public synchronized ImmutableSet<OfflinePlayer> getPlayers() {
         ImmutableSet.Builder<OfflinePlayer> players = ImmutableSet.builder();
         for (ScoreHolder playerName : this.board.getTrackedPlayers()) {
             players.add(Bukkit.getOfflinePlayer(playerName.getScoreboardName()));
@@ -223,7 +221,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<String> getEntries() {
+    public synchronized ImmutableSet<String> getEntries() {
         ImmutableSet.Builder<String> entries = ImmutableSet.builder();
         for (ScoreHolder entry : this.board.getTrackedPlayers()) {
             entries.add(entry.getScoreboardName());
@@ -232,27 +230,26 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public void clearSlot(DisplaySlot slot) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not supported yet
+    public synchronized void clearSlot(DisplaySlot slot) {
         Preconditions.checkArgument(slot != null, "Slot cannot be null");
         this.board.setDisplayObjective(CraftScoreboardTranslations.fromBukkitSlot(slot), null);
     }
 
     // Paper start
     @Override
-    public ImmutableSet<Score> getScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
+    public synchronized ImmutableSet<Score> getScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
         Preconditions.checkArgument(entity != null, "Entity cannot be null");
         return this.getScores(((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle());
     }
 
     @Override
-    public void resetScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
+    public synchronized void resetScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
         Preconditions.checkArgument(entity != null, "Entity cannot be null");
         this.resetScores(((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle());
     }
 
     @Override
-    public Team getEntityTeam(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
+    public synchronized Team getEntityTeam(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
         Preconditions.checkArgument(entity != null, "Entity cannot be null");
         return this.getEntryTeam(((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle().getScoreboardName());
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 8248cd6c908c82b6b7a18df7410a9a4a46a91959..f09b522a3a28ee86b3988897f66a8b5491482a37 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -389,7 +389,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
 
         // Folia start - block plugins not marked as supported
         if (!pdf.isFoliaSupported()) {
-            throw new InvalidPluginException("Plugin " + pdf.getFullName() + " is not marked as supporting regionised multithreading");
+            //throw new InvalidPluginException("Plugin " + pdf.getFullName() + " is not marked as supporting regionised multithreading");
         }
         // Folia end - block plugins not marked as supported
 
